# FAQ Programming - THEORY

![Programming Language](https://udemy-images.udemy.com/course/750x422/658604_d6b0_3.jpg)

## Уровень :skull: сложности:

- I'm too young to DIE === :godmode:
- Hey, not too ROUGH === :suspect:
- Hurt me PLENTY === :rage4:
- Ultra-VIOLENCE === :goberserk:
- NIGHTMARE === :feelsgood:
- INSANE === :finnadie:

  ![DOOM main character](http://vignette1.wikia.nocookie.net/doom/images/3/30/Doomguyface.jpg/revision/latest?cb=20110328073223)![DOOM main character](http://vignette1.wikia.nocookie.net/doom/images/3/30/Doomguyface.jpg/revision/latest?cb=20110328073223)![DOOM main character](http://vignette1.wikia.nocookie.net/doom/images/3/30/Doomguyface.jpg/revision/latest?cb=20110328073223)![DOOM main character](http://vignette1.wikia.nocookie.net/doom/images/3/30/Doomguyface.jpg/revision/latest?cb=20110328073223)![DOOM main character](http://vignette1.wikia.nocookie.net/doom/images/3/30/Doomguyface.jpg/revision/latest?cb=20110328073223)![DOOM main character](http://vignette1.wikia.nocookie.net/doom/images/3/30/Doomguyface.jpg/revision/latest?cb=20110328073223)![DOOM main character](http://vignette1.wikia.nocookie.net/doom/images/3/30/Doomguyface.jpg/revision/latest?cb=20110328073223)![DOOM main character](http://vignette1.wikia.nocookie.net/doom/images/3/30/Doomguyface.jpg/revision/latest?cb=20110328073223)![DOOM main character](http://vignette1.wikia.nocookie.net/doom/images/3/30/Doomguyface.jpg/revision/latest?cb=20110328073223)![DOOM main character](http://vignette1.wikia.nocookie.net/doom/images/3/30/Doomguyface.jpg/revision/latest?cb=20110328073223)

## :collision: Вопросы :collision:

1. :neckbeard: [История развития языка C#](#question-1) :godmode:

  - :point_right: Особенности оператора присваивания.
  - :point_right: Классификация операций.
  - :point_right: Алфавит и словарь языка.
  - :point_right: Константы и переменные.
  - :point_right: Объявление и инициализация.
  - :point_right: Классификация типов данных.

2. :neckbeard: [Структура программы](#question-1) :godmode:

  - :point_right: Достоинства.
  - :point_right: Лексемы.
  - :point_right: Правила построения выражений.
  - :point_right: Приоритет выполнения операций.
  - :point_right: Совместимость типов.
  - :point_right: Автоматическое и явное преобразование типов.

3. :neckbeard: [Стандартные функции управления вводом-выводом.](#question-1) :godmode:

4. :neckbeard: [Форматы преобразования данных.](#question-1) :suspect:

5. :neckbeard: [Основные понятия ООП.](#question-1) :godmode:

  - Объявление класса.
  - Модификаторы доступа перед классом.

6. :neckbeard: [Присваивание и сравнение объектов.](#question-1) :suspect:

7. :neckbeard: [Поля и константы, методы класса.](#question-1) :godmode:

8. :neckbeard: [Параметры методов. Параметры-значения. Параметры-ссылки.](#question-1) :suspect:

9. :neckbeard: [Конструкторы и финализаторы в классе.](#question-1) :suspect:

10. :neckbeard: [Прямой и косвенный вызов методов.](#question-1) :suspect:

![ENGLISH MOTHERFUCKER](http://lamcdn.net/lookatme.ru/post_image-image/1CoePZ07Bm6g1HWMWbMZmQ-article.jpg)

## :fire: Ответы :fire:

## :fire: ЗА ПРАВИЛЬНОСТЬ РЕШЕНИЙ НЕ ОТВЕЧАЮ. ТАК КАК НАДО САМИМ ЕЩЕ БЫЛО РАЗБИРАТЬ. И ЕСЛИ ВАМ НЕ НРАВИТСЯ, ТО: :fire:

![Fuck Yourself](http://s2.quickmeme.com/img/91/912bcb507515413fde835d7b906343c2964db7b1a360a4f373cef3daaad16122.jpg)

### Question 1

- Язык C# был разработан корпорацией Microsoft в конце 90-х годов как часть общей стратегии .NET. Впервые он был выпущен в виде альфа-версии в середине 2000 года. Главным разработчиком C# был Андерс Хейльсберг -- один из ведущих в мире специалистов по языкам программирования, который может похвалиться рядом заметных достижений в данной области.

![C# Connections](http://professorweb.ru/my/csharp/charp_theory/level1/files/img7659.png)

- С момента выпуска исходной версии 1.0 развитие C# происходило быстро. Вскоре после версии 1.0 корпорация Microsoft выпустила версию 1.1, в которую было внесено немало корректив, но мало значительных возможностей. Однако ситуация совершенно изменилась после выпуска версии C# 2.0.

- Появление версии 2.0 стало поворотным моментом в истории развития C#, поскольку в нее было введено много новых средств, в том числе обобщения, частичные типы и анонимные методы, которые основательно расширили пределы возможностей и область применения этого языка, а также повысили его эффективность.

- Появлением версии 3.0 корпорация Microsoft внедрила ряд новшеств, совершенно изменивших общее представление о программировании. К числу этих новшеств относятся, среди прочего, лямбда-выражения, язык интегрированных запросов (LINQ), методы расширения и неявно типизированные переменные.

- И так далее до C# 6.

- [Лексемы C#](http://victor192007.narod.ru/files/cs01.html)

- [Константы и переменные C#](https://msdn.microsoft.com/ru-ru/library/wew5ytx4(v=vs.90).aspx)

- [Встроенные типы данных](https://msdn.microsoft.com/ru-ru/library/cs7y5x0x(v=vs.90).aspx)

![C# Типы данных](http://professorweb.ru/my/csharp/charp_theory/level3/files/img3092.png)

```c#
int a = 5; // Variable

const b = 6; // Constanta
```

**Преимущества** `C#`:

- Подлинная объектная ориентированность.
- Компонентно-ориентированное программирование.
- Безопасный код.
- Унифицированная система типизации.
- Поддержка событийно-ориентированного программирования.

**Алфавит** `C#` **включает**:

- Буквы и символ подчеркивания;
- Цифры;
- Специальные символы, например +, 'звездочка', { и &;
- Пробельные символы (пробел и символы табуляции);
- Символы перевода строки.

### Question 2

- [Структура программы #1](https://msdn.microsoft.com/ru-ru/library/6c70zway(v=vs.90).aspx) и [Структура программы #2](http://softwaredesignart.net/%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B0-%D0%BA%D0%BE%D0%B4%D0%B0-ru/%D0%BE%D0%B1%D1%89%D0%B0%D1%8F-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D0%BD%D0%B0-c/)

- [Оператор присваивания](http://professorweb.ru/my/csharp/charp_theory/level3/3_11.php)

- **Классификация операций:**

  - Математические операции (+ - * /)
  - Операция присваивания (=)
  - Операции сравнения (> <)
  - Логические операции (или, и, не)
  - Операция последовательного выполнения (,)
  - Операции, возвращающие тип объекта (Операция, возвращающая информацию о типе: класс. GetType(); Операция, возвращающая объект, хранящий информацию о типе переменной: typeof(тип))
  - Операции преобразования типов (тип.переменная)
  - Операция обращения к элементам классов и структур (->)

- **Приоритет выполнения операций:**

  - Первичные (выражение в скобках, извлечение поля у объекта, вызов метода)
  - Унарные (+ -)
  - Бинарные (* / + -)
  - Сдвиг (>> <<)
  - Отношения, проверка типов (> < is as)
  - Эквивалентность (== !=)
  - Битовое и (&), исключающее битовое (^), битовое или (|)
  - Условное и (&&), условное или (||)
  - Присваивание (=)

- **Два типа считаются совместимыми если:**

  - Они имеют один и тот же тип;
  - Оба вещественные;
  - Оба целые и диапазон значений 2-го является подмножеством значений 1-го;
  - 1 тип -- вещественный, а 2 -- целый;
  - 1 тип -- строка, а 2 -- символ;
  - Тип 2 является прямым или косвенным потомком класса 1.

- Явное преобразование типов:

  ```c#
  // Example:
  double pi = 3.1415926;
  int entier = (int)pi;
  ```

- Автоматическое преобразование типов:

  ```c#
  // Examples:

  // Автоматическое приведение типов
  var name = "Egor";
  var age = 20;
  Console.WriteLine($"Hello! My name is {name} and my age is {age}");

  Console.ReadLine();
  ```

### Question 3

- ???

### Question 4

- ???

### Question 5

- Base knowledge: encapsulation, inheritance and polymorphism !!!

  ```c#
  <public/private/protected/internal> <static> class Sample {
  // props
  // methods
  // and other stuff ...
  }
  ```

- **Модификаторы доступа:**

  - `public`: Неограниченный доступ.
  - `protected`: Доступ ограничен содержащим классом или типами, которые являются производными от содержащего класса.
  - `internal`: Доступ ограничен текущей сборкой.
  - `private`: Доступ ограничен содержащим типом.

### Question 6

```c#
// Создание и сравнение объектов
public class Sample {
  public String Name {get; set;}
  public String Surname {get; set;}
}

// code in main

// Sample sample = new Sample { name: 'Egor', surname: 'Shazam'};

Sample sampleOne = new Sample();
sampleOne.Name = 'Egor';
sampleOne.Surname = 'Voziyanov';

Sample sampleTwo = new Sample();
sampleOne.Name = 'Ales';
sampleOne.Surname = 'Kazakevich';
```

- **Helpful links:**

  1. [Habra - сравнение объектов](https://habrahabr.ru/post/137680/)
  2. [MSDN - какое-то сравнение](https://habrahabr.ru/post/137680/)

- `public static bool ReferenceEquals(object objA, object objB)` – сравнивает объекты по ссылке.

- `public static bool Equals(object objA, object objB)` - сначала этот метод проверяет экземпляры на тождество и если объекты не тождественны, то проверяет их на null и делегирует ответственность за сравнение переопределяемому экземплярному методу Equals.

- `public virtual bool Equals(object obj)` – по умолчанию ведет себя так же, как метод ReferenceEquals, но переопределен для значимых типов.

- `public static bool operator` == (MyClass left, MyClass right) – c# предоставляет возможность переопределить оператор сравнения для пользовательских классов.

### Question 7

- [All about C# classes](http://professorweb.ru/my/csharp/charp_theory/level5/5_1.php)

```c#
public class Sample {
  // const of class
  public const double PI=3.141;
  public const double E = 2.81;
  public const double K;

  public Sample(){
    K = 2.5; // ошибка - константа должна быть определена до компиляции
  }
}
class Program {
  static void Main(string[] args) {
    Sample.E=3.8; // константу нельзя установить несколько раз
  }
}

// поле класса это просто переменная внутри класса - как пример для get и set
// также есть ствойство readonly - для чтения и нельзя дважды установить значение
```

### Question 8

- [MSDN](https://msdn.microsoft.com/ru-ru/library/8f1hz171.aspx)
- [Параметры методов C#](http://metanit.com/sharp/tutorial/2.9.php)

### Question 9

```c#
// Constructor
class Sample {
  // ...
  Sample () {}
}
```

```c#
// Finalize
class Sample {
  // ...
  ~Sample() {}
}
```

### Question 10

- ???

### Question 11

```c#
// one dimension array
int[] array = {1,2,3,4,5};
```

```c#
// two/multi dimension array
int[,] array {
  {1,2,3,4,5},
  {1,2,3,4,5},
  {1,2,3,4,5},
  {1,2,3,4,5},
  {1,2,3,4,5}
}
```

```c#
// ladder array
int[][] array = {
  {1,2,3},
  {1,2,3,4,5}
};
```

- [Ladder Array](http://professorweb.ru/my/csharp/charp_theory/level4/4_3.php)

```c#
int[] fibarray = new int[] { 0, 1, 1, 2, 3, 5, 8, 13 };
foreach (int element in fibarray) {
  System.Console.WriteLine(element);
}
```

```c#
// Var 1
for (int i = 0; i < houses.Count; i++) {
    houses[i] = new GameObject();
}

// Var 2
var houses = new GameObject[200].Select(h => new GameObject()).ToArray();

// Var 3
var houses = Enumerable.Repeat(0, 200).Select(h => new GameObject()).ToArray();

// Var 4
class Point {
  public int x;
  public int y;
}

point[] array = new point[100];
foreach(point p in array) {
  p = new Point();
}
array[0].x = 5;
```

### Question 12

- [String](http://professorweb.ru/my/csharp/charp_theory/level4/4_7.php)

```c#
// Chars
char a = 'a';
char[] arrOfChars = {'a', 'b', 'c'};

// String
string foo = 'qwerts';
string[] arrOfStrings = {'qwer', 'asddd', 'qwsaz'};

// Also
char[] chararray = {'e', 'x', 'a', 'm', 'p', 'l', 'e'};
string str = new string(chararray);
```
- [Форматирование строк](https://msdn.microsoft.com/ru-ru/library/system.string.format(v=vs.110).aspx)

- [String Builder](http://professorweb.ru/my/csharp/charp_theory/level4/4_8.php)

```c#
StringBuilder hello = new StringBuilder("Hello FUKKBOYS LLC!",120);
hello.AppendFormat("Welcome to the JUNGLE!");
```

### Question 13

- [Interfaces](http://professorweb.ru/my/csharp/charp_theory/level9/9_1.php)

```c#
public interface CalculationOperation {
  int Sum();
  int Mul();
}

class Sample : CalculationOperation {
  // ...

  public virtual Sum() {
    // ...
  }

  public virtual Sum() {
    // ...
  }
}
```

- [Default .Net Interfaces](http://www.intuit.ru/studies/courses/486/342/lecture/8245?page=2)

### Question 14

- [IDisposoble](http://professorweb.ru/my/csharp/charp_theory/level13/13_6.php)

```c#
using System;

namespace ConsoleApplication1
{
    // Данный класс реализует интерейс IDisposable
    class FinalizeObject : IDisposable {
        public int id { get; set; }

        public FinalizeObject(int id) {
            this.id = id;
        }

        // Реализуем метод Dispose()
        public void Dispose() {
            Console.WriteLine("Высвобождение объекта!");
        }
    }

    class Program {
        static void Main(string[] args) {
            FinalizeObject obj = new FinalizeObject(4);
            obj.Dispose();

            Console.Read();
        }
    }
}
```

```c#
FinalizeObject obj = new FinalizeObject(4);
try {
    // Выполнение необходимых операций
}
finally {
    obj.Dispose();
}

// Надо постоянно писать try/finally для того, чтобы точно значть метод Dispose() вызывался.
// Поэтому используют using

using (FinalizeObject obj = new FinalizeObject(4)) {
    // Необходимые действия
}
```

### Question 15

- [Индексаторы](http://professorweb.ru/my/csharp/charp_theory/level5/5_13.php)
- [Индексаторы MSDN](https://msdn.microsoft.com/ru-ru/library/6x16t2tx.aspx)

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ConsoleApplication1
{
    class MyArr
    {
        int[] arr;
        public int Length;

        public MyArr(int Size)
        {
            arr = new int[Size];
            Length = Size;
        }

        // Создаем простейший индексатор
        public int this[int index]
        {
            set
            {
                arr[index] = value;
            }

            get
            {
                return arr[index];
            }
        }
    }

    class Program
    {
        static void Main()
        {
            MyArr arr1 = new MyArr(Size: 5);
            Random ran = new Random();
            
            // Инициализируем каждый индекс экземпляра класса arr1
            for (int i = 0; i < arr1.Length; i++)
            {
                arr1[i] = ran.Next(1,100);
                Console.Write("{0}\t", arr1[i]);
            }

            Console.ReadLine();
        }
    }
}
```

### Question 16 

- [Базовое наследование](http://professorweb.ru/my/csharp/charp_theory/level7/7_1.php)
- [Конструктор и наследование](http://professorweb.ru/my/csharp/charp_theory/level7/7_3.php)

```c#
class Sample {
  public int x,y,z;

  public Sample(int x,int y,int z) {
    this.x = x;
    this.y = y;
    this.z = z;    
  }
}

class SampleInheriter : Sample {
  SampleInheriter(int point, int x,int y,int z) : base (x,y,z) {
     this.point = point;
  }

  public void Pointer(ClassA obj) {
    obj.x *= obj.point;
    obj.y *= obj.point;
    obj.z *= obj.point;
    Console.WriteLine("Новые координаты объекта: {0} {1} {2}", obj.x, obj.y, obj.z);
  }
}

class Program {
  static void Main() {
      ClassA obj = new ClassA(10, 1, 4, 3);
      Console.WriteLine("Координаты объекта: {0} {1} {2}", obj.x, 
        obj.y, obj.z);
      obj.Pointer(obj);

      Console.ReadLine();
  }
}
```

- Иногда требуется создать базовый класс, в котором определяется лишь самая общая форма для всех его производных классов, а наполнение ее деталями предоставляется каждому из этих классов. В таком классе определяется лишь характер методов, которые должны быть конкретно реализованы в производных классах, а не в самом базовом классе. Подобная ситуация возникает, например, в связи с невозможностью получить содержательную реализацию метода в базовом классе.
- Абстрактный метод создается с помощью указываемого модификатора типа abstract. У абстрактного метода отсутствует тело, и поэтому он не реализуется в базовом классе. Это означает, что он должен быть переопределен в производном классе, поскольку его вариант из базового класса просто непригоден для использования. 
Нетрудно догадаться, что абстрактный метод автоматически становится виртуальным и не требует указания модификатора virtual. 
В действительности совместное использование модификаторов virtual и abstract считается ошибкой. 
Для определения абстрактного метода служит приведенная ниже общая форма:

`abstract тип имя(список_параметров);`

- [Abastract](http://professorweb.ru/my/csharp/charp_theory/level7/7_7.php)

```c#
abstract class Foo {
  abstract public string Show() {}
}

class Bar : Foo {
  public override string Show() {
    //...
  }
}
```

- [Virtual](http://professorweb.ru/my/csharp/charp_theory/level7/7_6.php)

```c#
class Base {
  //...
  public virtual string ShowInfo() {
    return 'Hello! This is a ShowInfo method from Base class!';
  }
}

class Inheriter : Base {
  //...
  public override string ShowInfo() {
    return 'Hello! This is a ShowInfo method from Inheriter class!';
  }
}
```

### Question 17 

- Абстрактный класс смотри выше (да и так понятно).

```c#
// от sealed class НЕЛЬЗЯ наследоваться - типо singleton
sealed class SealedClass {
    public int x;
    public int y;
}

class SealedTest2 {
    static void Main() {
        SealedClass sc = new SealedClass();
        sc.x = 110;
        sc.y = 150;
        Console.WriteLine("x = {0}, y = {1}", sc.x, sc.y);
    }
}
```

### Question 18

- [Delegates](http://professorweb.ru/my/csharp/charp_theory/level10/10_1.php)
- [Delegates MSDN](https://msdn.microsoft.com/en-us/library/ms173172.aspx)
- **Делегат** представляет собой объект, который может ссылаться на метод. Следовательно, когда создается делегат, то в итоге получается объект, содержащий ссылку на метод. Более того, метод можно вызывать по этой ссылке. Иными словами, делегат позволяет вызывать метод, на который он ссылается.
- По сути, **делегат** — это безопасный в отношении типов объект, указывающий на другой метод (или, возможно, список методов) приложения, который может быть вызван позднее. 

```c#
delegate int IntOperation(int i, int j);

class Programm {
  int Add (int x, int x) {
    return x + y;
  }

  int Mul (int x, int x) {
    return x * y;
  }

  void Main() {
    // Сконструируем делегат
    IntOperation intOp1 = new IntOperation(Sum);

    int result = op1(5, 10);
    Console.WriteLine($"Result of add = {result}");

    // Изменим ссылку делегата на другой метод
    intOp1 = new IntOperation(Mul);
    result = op1(5, 10);
    Console.WriteLine($"Result of mul = {result}");
  }
}
```

```c#
public delegate void Del(string message);

// Create a method for a delegate.
public static void DelegateMethod(string message) {
  Console.WriteLine(message);
}

// Instantiate the delegate.
Del handler = DelegateMethod;

// Call the delegate.
handler("Hello World");

// Send delegate - callback as a parametr for a method
public void MethodWithCallback(int param1, int param2, Del callback) {
    callback("The number is: " + (param1 + param2).ToString());
}

MethodWithCallback(1, 2, handler);
```

- Exception handling with delegates ???

```c#
private delegate void StringHandlerDelegate(string s);
 
static void Main() {
    try {
        // Add two methods to delegate instance
        StringHandlerDelegate del = Method1;
        del += Method2;
 
        // Invoke
        del("Yooper");
    }
    catch (Exception xx) {
        Console.WriteLine("Exception: {0}", xx.Message);
    }
}

// Тут отработает только первый метод и не отработает второй
// Кажется то 
 
static void Method1(string text) {
    Console.WriteLine("Method1, {0}", text);
    throw new Exception("Problem in Method1");
}
 
static void Method2(string name) {
    Console.WriteLine("Method2, {0}", name);
}
```


### Question 19

- [Паттерн Обозреватель](http://metanit.com/sharp/patterns/3.2.php)
- Паттерн **"Наблюдатель"** (*Observer*) представляет поведенческий шаблон проектирования, который использует отношение "один ко многим". В этом отношении есть один наблюдаемый объект и множество наблюдателей. И при изменении наблюдаемого объекта автоматически происходит оповещение всех наблюдателей.
- Данный паттерн еще называют **Publisher-Subscriber** (*издатель-подписчик**), поскольку отношения издателя и подписчиков характеризуют действие данного паттерна: подписчики подписываются email-рассылку определенного сайта. Сайт-издатель с помощью email-рассылки уведомляет всех подписчиков о изменениях. А подписчики получают изменения и производят определенные действия: могут зайти на сайт, могут проигнорировать уведомления и т.д.
- Когда использовать паттерн Наблюдатель?
  + Когда система состоит из множества классов, объекты которых должны находиться в согласованных состояниях
  + Когда общая схема взаимодействия объектов предполагает две стороны: одна рассылает сообщения и является главным, другая получает сообщения и реагирует на них. Отделение логики обеих сторон позволяет их рассматривать независимо и использовать отдельно друга от друга.
  + Когда существует один объект, рассылающий сообщения, и множество подписчиков, которые получают сообщения. При этом точное число подписчиков заранее неизвестно и процессе работы программы может изменяться.

![Observer patter UML design](https://upload.wikimedia.org/wikipedia/commons/8/8a/Observer_UML.png)

- Инфа к диаграмме:
  + **Observable** — интерфейс, определяющий методы для добавления, удаления и оповещения наблюдателей;
  + **Observer** — интерфейс, с помощью которого наблюдатель получает оповещение;
  + **ConcreteObservable** — конкретный класс, который реализует интерфейс **Observable**;
  + **ConcreteObserver** — конкретный класс, который реализует интерфейс Observer.

![Observer c#](http://metanit.com/sharp/patterns/pics/observer.png)

- Формальное определение паттерна на языке `C#` может выглядеть следующим образом:

```c#
interface IObservable {
    void AddObserver(IObserver o);
    void RemoveObserver(IObserver o);
    void NotifyObservers();
}
class ConcreteObservable : IObservable {
    private List<IObserver> observers;
    public void AddObserver(IObserver o) {
        observers.Add(o);
    }
 
    public void RemoveObserver(IObserver o) {
        observers.Remove(o);
    }
 
    public void NotifyObservers() {
        foreach (IObserver observer in observers)
            observer.Update();
    }
}
 
interface IObserver {
    void Update();
}
class ConcreteObserver :IObserver {
    public void Update() {}
}
```

### Question 20

- [События](http://professorweb.ru/my/csharp/charp_theory/level10/10_7.php)
- [События - Habr](https://habrahabr.ru/post/213809/)

```c#
using System;

namespace ConsoleApplication1 {
    delegate void UI ();

    class MyEvent {
        // Объявляем событие
        public event UI UserEvent;

        // Используем метод для запуска события
        public void OnUserEvent() {
            UserEvent();
        }
    }

    class UserInfo {
        string uiName, uiFamily;
        int uiAge;

        public UserInfo(string Name, string Family, int Age) {
            this.Name = Name;
            this.Family = Family;
            this.Age = Age;
        }

        public string Name { set { uiName = value; } get { return uiName; } }
        public string Family { set { uiFamily = value; } get { return uiFamily; } }
        public int Age { set { uiAge = value; } get { return uiAge; } }

        // Обработчик события
        public void UserInfoHandler() {
            Console.WriteLine("Событие вызвано!\n");
            Console.WriteLine("Имя: {0}\nФамилия: {1}\nВозраст: {2}",Name,Family,Age);
        }
    }

    class Program{
        static void Main() {
            MyEvent evt = new MyEvent();
            UserInfo user1 = new UserInfo(Name: "Alex", Family: "Erohin", Age: 26);

            // Добавляем обработчик события
            evt.UserEvent += user1.UserInfoHandler;
           
            // Запустим событие
            evt.OnUserEvent();

            Console.ReadLine();
        }
    }
}
```

### Question 21

### Question 22

- [Props MSDN](https://msdn.microsoft.com/ru-ru/library/x9fsa0sw.aspx)
- [Props](http://professorweb.ru/my/csharp/charp_theory/level5/5_14.php)

```c#
// Virtual props
class MyBaseClass
{
    // virtual auto-implemented property. Overrides can only
    // provide specialized behavior if they implement get and set accessors.
    public virtual string Name { get; set; }

    // ordinary virtual property with backing field
    private int num;
    public virtual int Number
    {
        get { return num; }
        set { num = value; }
    }
}


class MyDerivedClass : MyBaseClass
{
    private string name;

   // Override auto-implemented property with ordinary property
   // to provide specialized accessor behavior.
    public override string Name
    {
        get
        {
            return name;
        }
        set
        {
            if (value != String.Empty)
            {
                name = value;
            }
            else
            {
                name = "Unknown";
            }
        }
    }

}
```

```c#
// compile with: csc /target:library abstractshape.cs
public abstract class Shape
{
    private string name;

    public Shape(string s)
    {
        // calling the set accessor of the Id property.
        Id = s;
    }

    public string Id
    {
        get
        {
            return name;
        }

        set
        {
            name = value;
        }
    }

    // Area is a read-only property - only a get accessor is needed:
    public abstract double Area
    {
        get;
    }

    public override string ToString()
    {
        return Id + " Area = " + string.Format("{0:F2}", Area);
    }
}

// compile with: csc /target:library /reference:abstractshape.dll shapes.cs
public class Square : Shape
{
    private int side;

    public Square(int side, string id)
        : base(id)
    {
        this.side = side;
    }

    public override double Area
    {
        get
        {
            // Given the side, return the area of a square:
            return side * side;
        }
    }
}

public class Circle : Shape
{
    private int radius;

    public Circle(int radius, string id)
        : base(id)
    {
        this.radius = radius;
    }

    public override double Area
    {
        get
        {
            // Given the radius, return the area of a circle:
            return radius * radius * System.Math.PI;
        }
    }
}

public class Rectangle : Shape
{
    private int width;
    private int height;

    public Rectangle(int width, int height, string id)
        : base(id)
    {
        this.width = width;
        this.height = height;
    }

    public override double Area
    {
        get
        {
            // Given the width and height, return the area of a rectangle:
            return width * height;
        }
    }
}
```

### Question 23

- ???

### Question 24

- ???

### Question 25

```c#
// Читает следующий символ из стандартного входного потока
Console.Read();

// Читает следующую строку символов из стандартного входного потока или нулевое 
// значение, пока пользователь не нажал клавишу Enter. Возвращается строка 
// типа string
Console.ReadLine();

// Поддерживает форматированный вывод, вывод всех стандартных типов
Console.Write();

//
Console.WriteLine();

// Поддерживает форматированный вывод, вывод всех стандартных типов. 
// Переводит курсор на следующую строку.
Cosnole.ReadKey();
```

### Question 26



### Question 27

- [Сборки](http://professorweb.ru/my/csharp/charp_theory/level1/1_7.php)

- Какой бы язык .NET не выбирался для программирования, важно понимать, что хотя двоичные .NET-единицы имеют такое же файловое расширение, как и двоичные единицы СОМ-серверов и неуправляемых программ Win32 (* . dll или * . ехе), внутренне они устроены абсолютно по-другому. Например, двоичные .NET-единицы * .dll не экспортируют методы для упрощения взаимодействия с исполняющей средой СОМ (поскольку .NET — это не СОМ). Более того, они не описываются с помощью библиотек СОМ-типов и не регистрируются в системном реестре. Пожалуй, самым важным является то, что они содержат не специфические, а наоборот, не зависящие от платформы инструкции на промежуточном языке (Intermediate Language — IL), а также метаданные типов. На следующей схеме показано, как все это выглядит:

![Shceme](http://professorweb.ru/my/csharp/charp_theory/level1/files/img9341.png)

- Отсюда следует, что **сборка** (*assembly*) — это логическая единица, содержащая скомпилированный код для .NET Framework, т.е. это полностью самодостаточный и скорее логический, нежели физический элемент. Это значит, что он может быть сохранен в более чем одном файле (хотя динамические сборки хранятся в памяти, а вовсе не в файлах). Если сборка хранится в более чем одном файле, то должен существовать один главный файл, содержащий точку входа и описывающий остальные файлы.

- Сборки имеют следующие составляющие:
  + Манифест, который содержит метаданные сборки
  + Метаданные типов. Используя эти метаданные, сборка определяет местоположение типов в файле приложения, а также места размещения их в памяти
  + Собственно код приложения на языке MSIL, в который компилируется код C#
  + Ресурсы

- Ключевым компонентом сборки является ее **манифест**. Если у сборки отсутствует манифест, то заключенный в ней код MSIL выполняться не будет. Манифест может находиться в одном файле с исполняемым кодом сборки, а может размещаться и в отдельном файле.

- Разлиные способы хранения манифеста сборок:

![Manifest](https://i-msdn.sec.s-msft.com/dynimg/IC204950.jpeg)

- Манифест сборки предназначен для следующих задач:
  + перечисление файлов, составляющих сборку;
  + сопоставление ссылок на типы и ресурсы сборки с файлами, содержащими объявления и реализации этих типов и ресурсов;
  + перечисление других сборок, от которых зависит эта сборка;
  + обеспечение косвенного обращения пользователей сборки к подробностям ее реализации;
  + предоставление собственного описания сборки;

- И расскзаать как создать DLL и как её заюзать:
  + Сначала выбрать при создание нового проекта библиотека классов или что-то еще (будет расширение `.dll`);
  + потом писать код (в основном `static`);
  + потом создать новый проект или прикрутить к уже существующему через -> Add References;
  + потом вызвать методы DLL Lib.
  + PROFIT !!!

### Question 28

- [Рефлексия #1](http://metanit.com/sharp/tutorial/14.1.php)

- [Рефлексия #2](http://metanit.com/sharp/tutorial/14.1.php)

- Рефлексия представляет собой процесс выявления типов во время выполнения приложения. Каждое приложение содержит набор используемых классов, интерфейсов, а также их методов, свойств и прочих кирпичиков, из которых складывается приложение. И рефлексия как раз и позволяет определить все эти составные элементы приложения.

- Получение типа. 
  + Чтобы управлять типом и получать всю информацию о нем, нам надо сперва получить данный тип. Это можно сделать тремя способами: с помощью ключевого слова `typeof`, с помощью метода `GetType()` класса `Object` и применяя статический метод `Type.GetType()`.

- Получение типа через `typeof`:

```c#
class Program {
    static void Main(string[] args) {
        Type myType = typeof(User);
         
        Console.WriteLine(myType.ToString());
        Console.ReadLine();
    }
}
 
public class User {
    public string Name { get; set; }
    public int Age { get; set; }
    public User(string n, int a) {
        Name = n;
        Age = a;
    }
    public void Display() {
        Console.WriteLine("Имя: {0}  Возраст: {1}");
    }
    public int Payment(int hours, int perhour) {
        return hours * perhour;
    }
}
```

- Получение типа с помощью метода `GetType` класса `Object`:

```c#

// + код сверху

User user = new User("Tom", 30);
Type myType = user.GetType();
```

- Получения типа - статический метод `Type.GetType()`:

```c#
Type myType = Type.GetType("TestConsole.User", false, true);
```

- Первый параметр указывает на полное имя класса с пространством имен. В данном случае класс User находится в пространстве имен TestConsole. Второй параметр указывает, будет ли генерироваться исключение, если класс не удастся найти. В данном случае значение false означает, что исключение не будет генерироваться. И третий параметр указывает, надо ли учитывать регистр символов в первом параметре. Значение true означает, что регистр не учитывается.

- [Аттрибуты](http://professorweb.ru/my/csharp/assembly/level2/2_9.php)

- Помни как пример аттрибут `#define <Условие> -> [Conditional("Условие")]`

### Question 29


### Question 30


### Question 31


### Question 32


### Question 33


### Question 34